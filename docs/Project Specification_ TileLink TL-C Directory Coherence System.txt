Microarchitecture Specification: TileLink Inclusive Directory Coherence (TIDC) System
Version: 1.0-Draft
Date: May 21, 2025
Author: Anish Miryala
1. Introduction
This document specifies the microarchitecture for the TileLink Inclusive Directory Coherence (TIDC) system, designed to provide cache coherence among four L1 caches and a unified L2 cache. The system leverages the SiFive TileLink Cached (TL-C) protocol to manage data consistency and permissions across the cache hierarchy. The L2 cache acts as the root of the coherence tree, maintaining a directory of L1 cache line states, while L1 caches act as leaves, initiating memory operations and responding to coherence probes.
The TIDC system adopts an inclusive coherence policy: any cache line present in an L1 cache must also be present in the L2 cache. The L2 TileLink Adapter manages the global coherence state through a directory and initiates coherence actions (e.g., probes) to L1s.
2. System-Wide Parameters
The following parameters define the configurable aspects of the TIDC system and must be consistently applied across all modules:
* WDATA (Data Bus Width in Bytes): Defines the width of the data bus in bytes. Must be a power of two. (e.g., 8 for 64-bit, 16 for 128-bit).
* WADDR (Address Field Width in Bits): Defines the width of each address field in bits. Must be at least 32.
* WSIZE (Size Field Width in Bits): Defines the width of each size field in bits, representing log2​(bytes). Must be at least 4.
* WSOURCE (Master Source ID Width in Bits): Number of bits needed to disambiguate per-link master sources. This determines the maximum number of outstanding requests an L1 can have to the L2.
* WSINK (Slave Sink ID Width in Bits): Number of bits needed to disambiguate per-link slave sinks. This determines the maximum number of outstanding Grant requests the L2 can have.
* CACHE_LINE_BITS: The size of a cache line in bits. This should be 2S×8 (e.g., if S=5, 25=32 bytes, so 32×8=256 bits). This must be a multiple of 8*W.
3. Module Hierarchy and Detailed Specifications
3.1. Top-Level System
TIDC_System #(
    parameter W = 8,
    parameter A = 32,
    parameter S = 5,
    parameter C = 4,
    parameter I = 4,
    parameter CACHE_LINE_BITS = 256 // Example for 32-byte cache line
)
├── L1_Cache_Controller_0
├── L1_Cache_Controller_1
├── L1_Cache_Controller_2
├── L1_Cache_Controller_3
├── L1_TL_Adapter_0
├── L1_TL_Adapter_1
├── L1_TL_Adapter_2
├── L1_TL_Adapter_3
├── L2_Cache_Controller
└── L2_TL_Adapter


3.2. L1 Cache Controller (L1_Cache_Controller_X)
Description: These are black-boxed functional L1 cache controllers w.r.t TIDC system. Their internal implementation (e.g., tag RAM, data RAM, LRU policy) is not specified here. They interact with the L1 TileLink Adapter through a defined interface.
Expected Inputs (To be updated once the caches are done):
* clk: Clock signal.
* rst_n: Active-low reset signal.
* core_request_valid [1 bit]: Indicates a valid request from the CPU core.
* core_request_addr [A bits]: Address for the CPU core request.
* core_request_type [2 bits]: Type of core request (e.g., 00=Read, 01=Write).
* core_request_data [CACHE_LINE_BITS bits]: Data for write requests.
* data_in_from_adapter_valid [1 bit]: Indicates valid data/status from L1 TL Adapter.
* data_in_from_adapter_data [CACHE_LINE_BITS bits]: Data received from L1 TL Adapter.
* data_in_from_adapter_error [1 bit]: Error status from L1 TL Adapter.
* probe_req_from_adapter_valid [1 bit]: Indicates a valid coherence probe request.
* probe_req_from_adapter_addr [A bits]: Address for the probe request.
* probe_req_from_adapter_permissions [3 bits]: New permissions requested by probe (toN, toB, toT).
Expected Outputs (To be updated once the caches are done):
* core_response_valid [1 bit]: Indicates a valid response to the CPU core.
* core_response_data [CACHE_LINE_BITS bits]: Data for read responses.
* core_response_error [1 bit]: Error status to the CPU core.
* l1_request_to_adapter_valid [1 bit]: Indicates a valid request to L1 TL Adapter (e.g., cache miss, write-back).
* l1_request_to_adapter_addr [A bits]: Address for the request to adapter.
* l1_request_to_adapter_type [3 bits]: Type of request to adapter (e.g., 000=ReadMiss, 001=WriteMiss, 010=WriteBack).
* l1_request_to_adapter_data [CACHE_LINE_BITS bits]: Data for write-back requests.
* l1_request_to_adapter_permissions [3 bits]: Requested permissions for cache misses (e.g., NtoB, NtoT).
* probe_ack_to_adapter_valid [1 bit]: Indicates a valid probe acknowledgment.
* probe_ack_to_adapter_addr [A bits]: Address for the probe acknowledgment.
* probe_ack_to_adapter_permissions [3 bits]: Current permissions being reported/downgraded (TtoT, TtoB, TtoN, BtoB, BtoN, NtoN).
* probe_ack_to_adapter_dirty_data [CACHE_LINE_BITS bits]: Dirty data if being written back.
3.3. L1 TileLink Adapter (L1_TL_Adapter_X)
Description: This module acts as a TileLink Master Agent on the TileLink interconnect. It translates requests from its associated L1 Cache Controller into TL-C messages (Channel A, C, E) and processes responses/probes from the L2 TileLink Adapter (Channel B, D). It manages the L1's local coherence state based on TL-C messages.
Internal Modules:
* Request Translator & Dispatcher:
   * Function: Converts L1 Cache Controller requests (l1_request_to_adapter) into appropriate TL-C Channel A messages (Acquire, PutFullData, PutPartialData, ArithmeticData, LogicalData, Intent) or Channel C Release/ReleaseData messages.
   * Logic:
      * Maps L1 read miss to TL-C Acquire (A-channel, a_opcode=6) with a_param set to NtoB (None to Branch for shared) or NtoT (None to Tip for exclusive).
      * Maps L1 write miss to TL-C Acquire (A-channel, a_opcode=6) with a_param set to NtoT (None to Tip).
      * Maps L1 write-back to TL-C ReleaseData (C-channel, c_opcode=7) with c_param indicating TtoN (Tip to None) or BtoN (Branch to None).
      * Handles Get/Put operations for uncached regions if L1 supports them.
   * Outputs: TL-C Channel A and C signals.
* Response Handler & State Updater:
   * Function: Processes incoming TL-C Channel D messages (Grant/GrantData, AccessAck/AccessAckData, HintAck, ReleaseAck) and Channel B messages (Probe, Get, PutFullData, etc.). Updates internal state and informs L1 Cache Controller.
   * Logic:
      * Demultiplexes d_opcode and b_opcode to determine message type.
      * For Grant or GrantData (D-channel, d_opcode=4/5), extracts data (d_data), error (d_error), and granted permissions (d_param). Updates the internal state for the cache line (e.g., from "pending" to "Branch" or "Tip"). Initiates a GrantAck (E-channel) by copying d_sink to e_sink.
      * For Probe (B-channel, b_opcode=6), extracts address and requested permissions (b_param). Forwards to L1 Cache Controller. Waits for probe_ack_to_adapter from L1, then forms ProbeAck/ProbeAckData (C-channel) with c_param reflecting the L1's actual permission change.
      * Passes d_error from Channel D and c_error from Channel C (if applicable for forwarded messages) to the L1 Cache Controller as data_in_from_adapter_error.
* Source ID Manager:
   * Function: Manages the unique a_source and c_source identifiers for outstanding requests originating from this L1 adapter.
   * Logic: Maintains a bitmap or free-list of C available source IDs (0 to 2C−1). Allocates an unused ID for each new Channel A or Channel C Release request. Deallocates the ID upon receipt of the corresponding response (matching d_source for A-channel requests, or ReleaseAck matching c_source for C-channel Release messages). Ensures that each inflight request has a unique ID.
* Concurrency & Ordering Manager (Detailed State Machine):
   * Function: Implements the Master Agent's portion of the TL-C concurrency rules and ensures proper ordering of requests and responses. This is a complex state machine managing the lifecycle of each outstanding transaction.
   * Logic:
      * Request Buffering: May buffer outgoing L1 requests if the TL-C channel is not ready or if a concurrency rule prevents immediate dispatch.
      * Acquire Rule: An L1 adapter must not issue an Acquire for a cache line if there is already an outstanding Acquire for the same line from this L1, or if a Grant for a previous Acquire is still pending. If multiple Acquires for the same block are needed (e.g., read miss followed by write miss before read data arrives), they must use unique transaction IDs (a_source) and the adapter must be prepared to handle out-of-order Grants.
      * Release Rule: An L1 adapter must not issue a Release if there is a pending Grant for the same block. Once a Release is issued, the adapter must not issue ProbeAcks, Acquires, or further Releases for that block until the ReleaseAck is received from the L2.
      * Probe Reaction: An L1 adapter must continue to process and respond to Probe messages even if it has an outstanding Grant pending in the network. If a Release for the same block is outstanding, the ProbeAck response may be delayed until the ReleaseAck is received.
      * Ready Signal Control: Manages a_ready, c_ready, and e_ready signals. These signals are driven by the L1 adapter to indicate its ability to accept data. ready must be held LOW only in accordance with TL-C deadlock freedom rules (e.g., bounded busy periods, or waiting for a response to an initiating request).
      * Burst Handling: Manages multi-beat transfers for Acquire (if data is included, though typically not), ReleaseData, ProbeAckData, GrantData, AccessAckData. Ensures control signals remain constant and data/mask/error signals change per beat as specified.
3.4. L2 Cache Controller
Description: This is a black-boxed functional L2 cache controller w.r.t TIDC system. Its internal implementation is not specified here. It interacts with the L2 TileLink Adapter.
Expected Inputs:
* clk: Clock signal.
* rst_n: Active-low reset signal.
* l2_cmd_from_adapter_valid [1 bit]: Valid command from L2 TL Adapter.
* l2_cmd_from_adapter_type [3 bits]: Command type (e.g., 000=Read, 001=Write, 010=Invalidate, 011=WriteBack).
* l2_cmd_from_adapter_addr [A bits]: Address for the command.
* l2_cmd_from_adapter_data [CACHE_LINE_BITS bits]: Data for write/write-back commands.
* l2_cmd_from_adapter_size [S bits]: Size of the operation.
* l2_cmd_from_adapter_dirty [1 bit]: Indicates if data is dirty (for write-back).
* probe_ack_from_adapter_valid [1 bit]: Valid probe acknowledgment from L2 TL Adapter.
* probe_ack_from_adapter_addr [A bits]: Address for the probe acknowledgment.
* probe_ack_from_adapter_permissions [3 bits]: Permissions being reported/downgraded.
* probe_ack_from_adapter_dirty_data [CACHE_LINE_BITS bits]: Dirty data from L1.
Expected Outputs:
* l2_response_to_adapter_valid [1 bit]: Valid response to L2 TL Adapter.
* l2_response_to_adapter_data [CACHE_LINE_BITS bits]: Data from L2 cache for read responses.
* l2_response_to_adapter_error [1 bit]: Error status from L2 cache.
3.5. L2 TileLink Adapter
Description: This module acts as the central TileLink Slave Agent and the coherence manager for the TIDC system. It receives requests from L1 TileLink Adapters, manages the directory, orchestrates coherence actions, and interfaces with the L2 Cache Controller and potentially main memory.
Internal Modules:
* Request Arbiter:
   * Function: Arbitrates among multiple incoming TL-C Channel A (from L1s) and Channel C (from L1s for releases/probe acks) requests.
   * Logic: Implements a fair arbitration scheme (e.g., round-robin, priority-based, or a combination). Crucially, it must prioritize messages according to the TileLink channel priority rules (A ≤ B ≤ C ≤ D ≤ E) to ensure deadlock freedom. For example, a ProbeAck (Channel C) arriving when an Acquire (Channel A) is pending should generally be given higher priority by the arbiter to ensure forward progress of the probe transaction.
   * Output: Selects one request to process at a time.
* Directory/Coherence Logic (The "Brain" - Detailed State Machine):
   * Function: Stores and manages the global coherence state for each cache line (present/not present in L1s, and their permissions). Orchestrates all coherence transactions.
   * Data Structures:
      * Directory RAM/CAM: Maps address tags to directory entries. Each directory entry would contain:
         * Global Coherence State: (e.g., Invalid, Shared, Exclusive, Modified, Pending-Probe, Pending-Grant).
         * L1 Presence Vector: A bitmask (4 bits for 4 L1s) indicating which L1s have a copy of the block.
         * L1 Permissions: For each L1 that has a copy, its specific permissions (Branch or Tip).
         * Pending Transaction Flags: To track outstanding Probe or Grant messages for a specific block, including the d_sink ID for pending Grants.
         * Request Queue: A small queue per directory entry to buffer multiple incoming requests for the same cache line while one is being processed.
   * Logic:
      * Acquire Handling (A-channel, a_opcode=6):
         * Looks up the block in the directory.
         * If exclusive permissions (NtoT, BtoT) are requested and other L1s have copies, determines which L1s need to be probed.
         * Issues Probe messages (Channel B, b_opcode=6 with b_param set to toN or toB for invalidation/downgrade) to those L1s.
         * Transitions directory state to "Pending-Probe" and waits for corresponding ProbeAck/ProbeAckData responses.
         * Once all necessary probes are resolved and directory is updated, sends Grant/GrantData (Channel D, d_opcode=4/5) to the requesting L1 with d_param set to the granted permissions (toB, toT, toN). Allocates a d_sink ID for this Grant.
      * Release Handling (C-channel, c_opcode=6/7):
         * Processes Release/ReleaseData messages. Updates directory based on c_param (e.g., TtoN, BtoN).
         * If ReleaseData contains dirty data, issues a write command (l2_cmd_from_adapter_type=WriteBack) to the L2 Cache Controller.
         * Sends ReleaseAck (Channel D, d_opcode=6) to the L1.
      * ProbeAck Handling (C-channel, c_opcode=4/5):
         * Processes ProbeAck/ProbeAckData messages. Updates directory based on the c_param (e.g., TtoN, BtoN, NtoN, TtoT, BtoB).
         * If ProbeAckData contains dirty data, issues a write command to the L2 Cache Controller.
         * Clears pending probe flags for the L1 that responded. If all probes for a transaction are complete, proceeds with the Grant to the original requesting L1.
      * GrantAck Handling (E-channel):
         * Processes GrantAck messages. Deallocates the d_sink ID associated with the Grant.
         * This signals that the L1 has completed its part of the transaction for the Grant and the L2 can now consider the block's state fully stable in the requesting L1. This is crucial for serialization.
      * L2 Cache Controller Interaction: Translates incoming TL-C requests (e.g., Acquire from L1 requiring data) into l2_cmd_from_adapter (read command) and processes l2_response_to_adapter and l2_data_to_adapter from the L2 Cache Controller. Initiates writes to L2 for dirty data from ReleaseData or ProbeAckData.
      * Error Handling: If c_error is asserted on an incoming Channel C message, or if the L2 Cache Controller signals an error via l2_response_to_adapter_error, the L2 adapter must generate an appropriate TL-C error response (d_error on Channel D) to the originating L1. This error must be logged internally.
   * Outputs: TL-C Channel B and D signals. Also sends l2_cmd_from_adapter to L2 Cache Controller.
* Sink ID Manager:
   * Function: Manages the unique d_sink identifiers for outstanding Grant requests initiated by the L2 adapter on Channel D.
   * Logic: Maintains a bitmap or free-list of I available sink IDs (0 to 2I−1). Allocates an unused ID for each new Grant request. Deallocates the ID upon receipt of the corresponding GrantAck message (matching e_sink). Ensures uniqueness of inflight d_sink values.
* Concurrency & Ordering Manager (Detailed State Machine):
   * Function: Implements the Slave Agent's portion of the TL-C concurrency rules to guarantee deadlock freedom and correct transaction serialization.
   * Logic:
      * Grant Rule: An L2 adapter must not issue a Grant if there is a pending ProbeAck for the same block. Once a Grant is issued, the adapter must not issue Probe messages for that block until a GrantAck is received.
      * Probe Rule: An L2 adapter must not issue a Probe if there is a pending GrantAck on the block. Once a Probe is issued, the adapter must not issue further Probes for that block until a ProbeAck is received.
      * Ready Signal Control: Manages a_ready and c_ready signals. These signals are driven by the L2 adapter to indicate its ability to accept data. ready must be held LOW only in accordance with TL-C deadlock freedom rules (e.g., bounded busy periods, or waiting for a response to an initiating request from L2 to main memory).
      * Bounded Busy Periods: The L2 adapter may enter bounded busy periods where ready is held LOW (e.g., during L2 cache access or main memory access), but these periods must not exceed a fixed, predefined number of cycles. Between busy periods, the adapter must accept at least one beat.
4. TileLink Interconnect
Description: The physical wires and handshaking logic that connect the Master (L1 Adapters) and Slave (L2 Adapter) interfaces. It consists of five logically independent channels: A, B, C, D, and E.
Channels (Unidirectional):
* Channel A (Master to Slave): Carries L1 requests (Acquire, Get, PutFullData, PutPartialData, ArithmeticData, LogicalData, Intent).
* Channel B (Slave to Master): Carries L2 requests to L1s (Probe, Get, PutFullData, PutPartialData, ArithmeticData, LogicalData, Intent).
* Channel C (Master to Slave): Carries L1 responses to L2 probes (ProbeAck, ProbeAckData) and voluntary write-backs (Release, ReleaseData).
* Channel D (Slave to Master): Carries L2 responses to L1 requests (Grant, GrantData, AccessAck, AccessAckData, HintAck, ReleaseAck).
* Channel E (Master to Slave): Carries final acknowledgments (GrantAck) to L2, for serialization.
Flow Control (Ready/Valid Handshaking):
* Each channel uses a valid/ready handshaking protocol.
* valid must never depend on ready (no combinational path from ready to valid). This is critical for deadlock freedom.
* A beat is exchanged only when both ready and valid are HIGH.
* Burst Messages: Multi-beat transfers are supported.
   * Data Type Signals (*_data, *_mask): Can change on every beat.
   * Final Type Signals (*_error): Can only change on the final beat of a burst.
   * Control Type Signals (*_opcode, *_param, *_size, *_source, *_address, *_sink): Must be held constant for the entire duration of a burst.
Priorities (for Deadlock Freedom):
* The TileLink network is designed to be deadlock-free by construction.
* The prioritization of messages across channels is A ≤ B ≤ C ≤ D ≤ E, in order of increasing priority. This strict prioritization ensures that messages flowing through the TileLink network never enter a routing or hold-and-wait loop.
Clocking, Reset, and Power:
* Synchronous Protocol: TileLink is a synchronous bus protocol. All master and slave interfaces on a given link must share the same clock and reset signals.
* Clock: Inputs are sampled on the rising edge. Output signals may only change after the rising edge of the clock.
* Reset: Active HIGH.
   * May be asserted asynchronously.
   * Must be deasserted synchronously with a rising edge of clock.
   * During reset, a_valid, c_valid, and e_valid must be driven LOW by the master.
   * During reset, b_valid and d_valid must be driven LOW by the slave.
   * All valid signals must be driven LOW for at least 100 cycles while reset is asserted to ensure proper initialization.
   * ready, control, and data signals are free to take any value during reset.
* Power/Clock Domain Crossing: It is forbidden for one side of a TileLink link to power down while its opposite is powered on. If TileLink must cross between power or clock domains, a dedicated TileLink-to-TileLink adapter is required. This adapter acts as a slave in one domain and a master in the other, allowing the two interfaces to be safely powered, clocked, and reset separately. This specification assumes all L1/L2 adapters are within the same clock/power domain.
* Infinitely Patient Agents: TileLink agents waiting on other TileLink agents must be infinitely patient. Timeouts that cause alternative messages to be generated are expressly forbidden within the TileLink network itself. Watchdogs that trigger a system reset are acceptable if confidence in agent implementations is low.
5. Verification Considerations
A comprehensive verification plan is critical for a coherent cache system.
* Directed Tests:
   * Basic Operations: Verify all TL-C message types and their expected responses (e.g., L1 read miss -> Acquire -> GrantData -> GrantAck).
   * Coherence Scenarios:
      * Cache-to-cache transfers (L1-A writes, L1-B reads -> L1-A probes, L1-B provides data to L2, L2 grants to L1-A).
      * Write-backs and evictions (L1 writes dirty data, evicts -> ReleaseData -> ReleaseAck).
      * Concurrent reads/writes to the same line from multiple L1s.
      * Read/write hits and misses in L1.
   * Error Propagation: Test scenarios where L2 or L1 controllers signal errors and verify correct TL-C error message generation and handling.
* Randomized Testing:
   * Use constrained random stimulus generation to explore a wider range of scenarios, including out-of-order responses (where permitted by TL-C).
   * Randomize delays on ready signals to stress flow control and concurrency logic.
* Coverage:
   * Implement functional coverage for all TL-C message types, coherence state transitions, and concurrency scenarios.
* Assertions:
   * Use SystemVerilog Assertions (SVA) to check TL-C protocol compliance (e.g., valid not dependent on ready, correct opcode/param usage, source/sink ID uniqueness, burst signal stability).
   * Assert coherence invariants (e.g., a line can only be Tip in one L1 at a time).
* Formal Verification (Highly Recommended):
   * For critical coherence properties (e.g., mutual exclusion for Tip state, data consistency), formal verification (e.g., model checking) can provide exhaustive proof of correctness, which is very difficult to achieve with simulation alone.
6. Performance Considerations
While correctness is paramount, performance is also a key aspect of cache systems.
* Buffer Sizing: Carefully size internal FIFOs/buffers within the L1 and L2 adapters (e.g., request queues, response queues) to balance latency and throughput. Too small, and you introduce stalls; too large, and you consume excessive area.
* Arbitration Fairness: The request arbiter in the L2 adapter should be fair to all L1s to prevent starvation. Consider round-robin or weighted round-robin schemes.
* Critical Path Analysis: Identify the longest combinational paths in your design, especially in the coherence logic, and optimize them to meet your target clock frequency.
* Latency vs. Throughput: Understand the trade-offs. Deeper pipelines might improve frequency (throughput) but increase latency.
* Directory Lookup Speed: The directory lookup in the L2 adapter is critical. Ensure its implementation (e.g., CAM, banked RAMs) is fast enough to avoid becoming a bottleneck.
________________